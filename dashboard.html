<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cliniko Physiotherapy Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script>
        // Customizing Tailwind theme with the new color palette
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'brand-white': '#FFFFFF',
                        'brand-light-pink': '#FCE7F3',
                        'brand-dark-pink': '#BE185D',
                        'brand-light-green': '#D1FAE5',
                        'brand-dark-teal': '#0F766E',
                        'brand-gray': '#F3F4F6',
                        'brand-text-dark': '#1F2937',
                        'brand-text-light': '#6B7280',
                        'brand-light-blue': '#E0F2FE',
                        'brand-dark-blue': '#1E40AF',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FFFFFF; /* brand-white */
        }
        .tab-button {
            padding: 0.75rem 1.5rem;
            border: none;
            background: transparent;
            color: #6B7280; /* brand-text-light */
            cursor: pointer;
            font-weight: 600;
            transition: color 0.2s ease, border-color 0.2s ease;
            border-bottom: 2px solid transparent;
        }
        .active-tab {
            color: #0F766E; /* brand-dark-teal */
            border-bottom-color: #0F766E; /* brand-dark-teal */
        }
        .metric-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-radius: 0.75rem;
        }
        .metric-card.interactive {
             cursor: pointer;
        }
        .metric-card.interactive:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        #chart-modal {
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body class="bg-brand-white text-brand-text-dark">

    <div class="container mx-auto p-4 md:p-8">
        <header class="mb-8 flex items-center justify-start">
            <img src="https://raw.githubusercontent.com/NickPez36/Cliniko_Dashy/main/assets/logo.webp" alt="Clinic Logo" class="h-24 w-24 mr-6">
            <div>
                <h1 class="text-3xl md:text-4xl font-bold text-brand-text-dark">Spectrum Health Co Dashboards</h1>
                <p class="text-brand-text-light mt-2">Weekly Performance Metrics</p>
            </div>
        </header>

        <!-- Loading State -->
        <div id="initial-loading" class="text-center p-8">
            <p class="text-lg text-brand-text-light">Fetching live data from GitHub...</p>
            <p id="loading-status" class="text-brand-dark-teal mt-2"></p>
        </div>

        <!-- Main Dashboard Content (hidden initially) -->
        <div id="main-dashboard" class="hidden">
            <!-- Filters -->
            <div class="bg-brand-gray rounded-lg shadow-lg p-4 mb-8 flex flex-col md:flex-row gap-4 items-center justify-center">
                <div id="practitioner-filter-container" class="w-full md:w-1/3">
                    <label for="practitioner-select" class="block text-sm font-medium text-brand-text-dark mb-1">Practitioner</label>
                    <select id="practitioner-select" class="w-full bg-white border-gray-300 text-brand-text-dark rounded-md shadow-sm focus:ring-brand-dark-teal focus:border-brand-dark-teal"></select>
                </div>
                <div class="w-full md:w-1/3">
                    <label for="year-select" class="block text-sm font-medium text-brand-text-dark mb-1">Year</label>
                    <select id="year-select" class="w-full bg-white border-gray-300 text-brand-text-dark rounded-md shadow-sm focus:ring-brand-dark-teal focus:border-brand-dark-teal"></select>
                </div>
                <div class="w-full md:w-1/3">
                    <label for="week-select" class="block text-sm font-medium text-brand-text-dark mb-1">Week</label>
                    <select id="week-select" class="w-full bg-white border-gray-300 text-brand-text-dark rounded-md shadow-sm focus:ring-brand-dark-teal focus:border-brand-dark-teal"></select>
                </div>
            </div>

            <!-- Tabs -->
            <div class="flex border-b border-gray-200 mb-8">
                <button id="practitioner-tab" class="tab-button active-tab">Practitioner Dashboard</button>
                <button id="clinic-tab" class="tab-button">Clinic Dashboard</button>
            </div>

            <!-- Practitioner Dashboard Content -->
            <div id="practitioner-dashboard-content">
                <!-- Section 1: Practitioner's Weekly Summary -->
                <div>
                    <h2 class="text-2xl font-bold text-brand-text-dark mb-4">Practitioner's Weekly Summary</h2>
                    <div id="practitioner-summary-content" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 md:gap-6">
                        <!-- Summary Cards will be injected here -->
                    </div>
                </div>

                <!-- Section 2: Patient Journey -->
                <div class="mt-12">
                    <h2 class="text-2xl font-bold text-brand-text-dark mb-4">Patient Journey</h2>
                    <div id="patient-journey-content" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 md:gap-6">
                         <!-- Journey Cards will be injected here -->
                    </div>
                </div>
                
                <!-- Section 3: Group Exercise Class Summary -->
                <div id="group-class-section" class="mt-12 hidden">
                    <h2 class="text-2xl font-bold text-brand-text-dark mb-4">Group Exercise Class Summary</h2>
                    <div id="group-class-content" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 md:gap-6">
                         <!-- Group Class Cards will be injected here -->
                    </div>
                </div>
            </div>

            <!-- Clinic Dashboard Content -->
            <div id="clinic-dashboard-content" class="hidden">
                 <!-- Section 1: Clinic Summary -->
                 <div>
                    <h2 class="text-2xl font-bold text-brand-text-dark mb-4">Overall Clinic Summary</h2>
                    <div id="clinic-summary-content" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 md:gap-6">
                        <!-- Clinic Summary Cards will be injected here -->
                    </div>
                </div>

                <!-- Section 2: Clinic Group Class Summary -->
                <div id="clinic-group-class-section" class="mt-12 hidden">
                    <h2 class="text-2xl font-bold text-brand-text-dark mb-4">Clinic-Wide Group Class Summary</h2>
                    <div id="clinic-group-class-content" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 md:gap-6">
                         <!-- Clinic Group Class Cards will be injected here -->
                    </div>
                </div>
                
                <!-- Section 3: Charts -->
                <div id="charts-container" class="grid grid-cols-1 lg:grid-cols-2 gap-4 md:gap-6 mt-12">
                    <div class="bg-brand-gray p-4 rounded-lg shadow-lg">
                        <h3 class="text-lg font-semibold text-brand-text-dark mb-4">Weekly Service Mix (Category)</h3>
                        <canvas id="categoryMixChart"></canvas>
                    </div>
                    <div class="bg-brand-gray p-4 rounded-lg shadow-lg">
                        <h3 class="text-lg font-semibold text-brand-text-dark mb-4">Initial vs. Return Appointments</h3>
                        <canvas id="typeMixChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Chart Modal -->
    <div id="chart-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-brand-white rounded-lg shadow-xl w-full max-w-4xl max-h-full flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-gray-200">
                <h2 id="modal-title" class="text-xl font-bold text-brand-text-dark"></h2>
                <button id="modal-close-button" class="text-brand-text-light hover:text-brand-text-dark text-3xl leading-none">&times;</button>
            </div>
            <div id="modal-summary" class="flex justify-around p-4 bg-brand-gray text-center border-b border-gray-200">
                <div><p class="text-sm text-brand-text-light">Q1 Avg</p><p id="modal-q1-avg" class="text-xl font-bold text-brand-text-dark"></p></div>
                <div><p class="text-sm text-brand-text-light">Q2 Avg</p><p id="modal-q2-avg" class="text-xl font-bold text-brand-text-dark"></p></div>
                <div><p class="text-sm text-brand-text-light">Q3 Avg</p><p id="modal-q3-avg" class="text-xl font-bold text-brand-text-dark"></p></div>
                <div><p class="text-sm text-brand-text-light">Q4 Avg</p><p id="modal-q4-avg" class="text-xl font-bold text-brand-text-dark"></p></div>
                <div class="border-l border-gray-300 pl-4 ml-4"><p class="text-sm text-brand-text-light">Annual Avg</p><p id="modal-annual-avg" class="text-xl font-bold text-brand-text-dark"></p></div>
            </div>
            <div class="p-4 flex-grow overflow-y-auto">
                <canvas id="modal-chart"></canvas>
            </div>
        </div>
    </div>


    <script>
        // --- GLOBAL VARIABLES & CONFIG ---
        let allEvents = [];
        let invoicesData = [];
        let categoryMixChart, typeMixChart, modalChart;
        let globalPatientFirstAppointment = {};

        const PRACTITIONER_HOURS_HISTORY = {
            'Isabella Coluccio': [
                { startDate: '2000-01-01', endDate: '9999-12-31', hours: 33 }
            ],
            'Kate Deaves': [
                { startDate: '2000-01-01', endDate: '9999-12-31', hours: 27 }
            ],
            'Andrew Lovell': [
                { startDate: '2000-01-01', endDate: '9999-12-31', hours: 32 }
            ],
            'Caitlin Wright': [
                { startDate: '2000-01-01', endDate: '9999-12-31', hours: 32 }
            ],
            'Arron Huynh': [
                { startDate: '2000-01-01', endDate: '9999-12-31', hours: 14 }
            ]
        };

        const METRIC_BENCHMARKS = {
            totalBookedAppointments: 120,
            totalCompletedAppointments: 120,
            utilizationRate: 80,
            cancellationRate: 15,
            didNotAttendRate: 5,
            rebookingRate: 80,
            treatmentNoteCompletionRate: 90,
            iarRate: 95,
            pvaCliniko: 8,
            pvaMatured3Mo: 8,
            totalClasses: 5,
            totalGroupAttendance: 30,
            classCancellationRate: 15
        };

        // --- UTILITY FUNCTIONS ---
        function getPractitionerHoursForDate(practitionerName, date) {
            const history = PRACTITIONER_HOURS_HISTORY[practitionerName];
            if (!history) return 0;

            const checkDate = new Date(date);

            for (const period of history) {
                const startDate = new Date(period.startDate);
                const endDate = new Date(period.endDate);
                if (checkDate >= startDate && checkDate <= endDate) {
                    return period.hours;
                }
            }
            return 0; // Default if no period matches
        }

        function robustDateParser(dateString) {
            if (!dateString || typeof dateString !== 'string') return null;
            
            // Format 1: YYYY-MM-DD HH:MM:SS Z
            let match = dateString.match(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2}):(\d{2})/);
            if (match) {
                const [_, year, month, day, hour, minute, second] = match.map(Number);
                return new Date(Date.UTC(year, month - 1, day, hour, minute, second));
            }

            // Format 2: DD/MM/YYYY HH:MM
            match = dateString.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})\s(\d{2}):(\d{2})/);
            if (match) {
                const [_, day, month, year, hour, minute] = match.map(Number);
                return new Date(Date.UTC(year, month - 1, day, hour, minute));
            }
            
            // Fallback for just date: DD/MM/YYYY
             match = dateString.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
            if (match) {
                const [_, day, month, year] = match.map(Number);
                return new Date(Date.UTC(year, month - 1, day));
            }

            return null; // Return null if no format matches
        }
        
        function getWeekNumber(d) {
            d = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        }

        function getStartOfWeek(year, week) {
            const simple = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));
            const dayOfWeek = simple.getUTCDay();
            const isoWeekStart = simple;
            isoWeekStart.setUTCDate(simple.getUTCDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1));
            return isoWeekStart;
        }

        const formatCurrency = (value) => new Intl.NumberFormat('en-AU', { style: 'currency', currency: 'AUD' }).format(value);

        // --- DATA FETCHING & INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            const initialLoading = document.getElementById('initial-loading');
            const loadingStatus = document.getElementById('loading-status');
            const mainDashboard = document.getElementById('main-dashboard');
            
            // Tab handling
            const practitionerTab = document.getElementById('practitioner-tab');
            const clinicTab = document.getElementById('clinic-tab');
            const practitionerContent = document.getElementById('practitioner-dashboard-content');
            const clinicContent = document.getElementById('clinic-dashboard-content');
            const practitionerFilterContainer = document.getElementById('practitioner-filter-container');

            practitionerTab.addEventListener('click', () => {
                practitionerTab.classList.add('active-tab');
                clinicTab.classList.remove('active-tab');
                practitionerContent.classList.remove('hidden');
                clinicContent.classList.add('hidden');
                practitionerFilterContainer.classList.remove('hidden');
            });

            clinicTab.addEventListener('click', () => {
                clinicTab.classList.add('active-tab');
                practitionerTab.classList.remove('active-tab');
                clinicContent.classList.remove('hidden');
                practitionerContent.classList.add('hidden');
                practitionerFilterContainer.classList.add('hidden');
            });


            const appointmentsUrl = 'https://raw.githubusercontent.com/NickPez36/Cliniko_Dashy/main/data/Appointments.csv';
            const invoicesUrl = 'https://raw.githubusercontent.com/NickPez36/Cliniko_Dashy/main/data/Invoices.csv';

            loadingStatus.textContent = 'Fetching Appointments.csv...';
            const fetchAppointments = fetch(appointmentsUrl).then(res => res.ok ? res.text() : Promise.reject(`Appointments.csv: ${res.statusText}`));

            loadingStatus.textContent = 'Fetching Invoices.csv...';
            const fetchInvoices = fetch(invoicesUrl).then(res => res.ok ? res.text() : Promise.reject(`Invoices.csv: ${res.statusText}`));

            Promise.all([fetchAppointments, fetchInvoices])
                .then(([appointmentsCSV, invoicesCSV]) => {
                    loadingStatus.textContent = 'Processing data...';
                    initializeDashboard(appointmentsCSV, invoicesCSV);
                    initialLoading.style.display = 'none';
                    mainDashboard.classList.remove('hidden');
                })
                .catch(error => {
                    console.error("Error fetching data:", error);
                    initialLoading.innerHTML = `<p class="text-red-400">Failed to load data. Please check the GitHub repository is public and file paths are correct.</p><p class="text-sm text-gray-500 mt-2">${error}</p>`;
                });
        });
        
        // --- DASHBOARD INITIALIZATION AND LOGIC ---
        function initializeDashboard(appointmentsCSV, invoicesCSV) {
            const practitionerSelect = document.getElementById('practitioner-select');
            const yearSelect = document.getElementById('year-select');
            const weekSelect = document.getElementById('week-select');
            
            const appointmentsResult = Papa.parse(appointmentsCSV, { header: true, skipEmptyLines: true });
            const invoicesResult = Papa.parse(invoicesCSV, { header: true, skipEmptyLines: true });
            
            const appointmentsRaw = appointmentsResult.data;
            invoicesData = invoicesResult.data;

            allEvents = appointmentsRaw
                .map(appt => ({
                    ...appt,
                    parsedStartTime: robustDateParser(appt['Start Time']),
                    parsedEndTime: robustDateParser(appt['End Time'])
                }))
                .filter(appt => appt.parsedStartTime && appt.parsedEndTime && appt['Practitioner ID']);
            
            // Pre-calculate first appointment for all patients globally for efficiency
            allEvents.filter(e => e['PatientID(s)']).sort((a, b) => a.parsedStartTime - b.parsedStartTime).forEach(e => {
                const pid = e['PatientID(s)'];
                if (pid && !globalPatientFirstAppointment[pid]) {
                    globalPatientFirstAppointment[pid] = e.parsedStartTime;
                }
            });

            const practitioners = [...new Set(allEvents.map(a => a.Practitioner))]
                .filter(name => {
                    if (!name || !name.includes(' ')) return false;
                    const lowerName = name.trim().toLowerCase();
                    const invalidKeywords = ['true', 'false', 'n/a', 'katalyst', 'cliniko', 'spectrum', 'headaches', 'exercise physiology'];
                    if (lowerName.length <= 4 || !isNaN(lowerName)) return false;
                    return !invalidKeywords.some(keyword => lowerName.includes(keyword));
                });
                
            practitioners.forEach(name => practitionerSelect.add(new Option(name, name)));

            function populateYears() {
                yearSelect.innerHTML = '';
                const years = [...new Set(allEvents.map(e => e.parsedStartTime.getUTCFullYear()))].sort((a,b) => b-a);
                years.forEach(year => yearSelect.add(new Option(year, year)));
                populateWeeks();
            }

            function populateWeeks() {
                weekSelect.innerHTML = '';
                const selectedYear = parseInt(yearSelect.value);
                const eventsInYear = allEvents.filter(e => e.parsedStartTime.getUTCFullYear() === selectedYear);
                const weeks = [...new Set(eventsInYear.map(e => getWeekNumber(e.parsedStartTime)))].sort((a,b) => a-b);
                weeks.forEach(week => {
                    const weekStartDate = getStartOfWeek(selectedYear, week);
                    const weekStartDateFormatted = `${weekStartDate.getUTCDate().toString().padStart(2, '0')}/${(weekStartDate.getUTCMonth() + 1).toString().padStart(2, '0')}/${weekStartDate.getUTCFullYear()}`;
                    weekSelect.add(new Option(`Week ${week} (${weekStartDateFormatted})`, week));
                });
                updateDashboard();
            }

            practitionerSelect.addEventListener('change', updateDashboard);
            yearSelect.addEventListener('change', populateWeeks);
            weekSelect.addEventListener('change', updateDashboard);
            
            // Modal event listeners
            document.getElementById('practitioner-dashboard-content').addEventListener('click', (e) => {
                const card = e.target.closest('.metric-card');
                if (card && card.classList.contains('interactive')) {
                    const metricType = card.dataset.metric;
                    const metricTitle = card.querySelector('h3').textContent;
                    showPractitionerYearlyTrendChart(metricType, metricTitle);
                }
            });

            document.getElementById('clinic-dashboard-content').addEventListener('click', (e) => {
                 const card = e.target.closest('.metric-card');
                if (card && card.classList.contains('interactive')) {
                    const metricType = card.dataset.metric;
                    const metricTitle = card.querySelector('h3').textContent;
                    showClinicYearlyTrendChart(metricType, metricTitle);
                }
            });
            
            const modal = document.getElementById('chart-modal');
            const modalCloseButton = document.getElementById('modal-close-button');
            modalCloseButton.addEventListener('click', () => modal.classList.add('hidden'));
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.add('hidden'); });

            populateYears();
        }

        // --- MAIN UPDATE FUNCTION ---
        function updateDashboard() {
            // Practitioner Dashboard Elements
            const practitionerSummaryContent = document.getElementById('practitioner-summary-content');
            const patientJourneyContent = document.getElementById('patient-journey-content');
            const groupClassSection = document.getElementById('group-class-section');
            const groupClassContent = document.getElementById('group-class-content');

            // Clinic Dashboard Elements
            const clinicSummaryContent = document.getElementById('clinic-summary-content');
            const clinicGroupSection = document.getElementById('clinic-group-class-section');
            const clinicGroupContent = document.getElementById('clinic-group-class-content');
            
            // Filter values
            const selectedPractitionerName = document.getElementById('practitioner-select').value;
            const selectedYear = parseInt(document.getElementById('year-select').value);
            const selectedWeek = parseInt(document.getElementById('week-select').value);
            
             const createCardHTML = (metric, type, interactive = false) => {
                let bgColor, titleColor, valueColor, subtitleColor, interactiveClass = interactive ? 'interactive' : '';
                if (type === 'summary') { bgColor = 'bg-brand-light-green'; titleColor = 'text-brand-dark-pink'; valueColor = 'text-brand-dark-pink'; subtitleColor = 'text-pink-900 opacity-70';
                } else if (type === 'journey') { bgColor = 'bg-brand-light-pink'; titleColor = 'text-brand-dark-teal'; valueColor = 'text-brand-dark-teal'; subtitleColor = 'text-teal-900 opacity-70';
                } else { bgColor = 'bg-brand-light-blue'; titleColor = 'text-brand-dark-blue'; valueColor = 'text-brand-dark-blue'; subtitleColor = 'text-blue-900 opacity-70'; }
                return `<div class="${bgColor} p-4 rounded-lg shadow-lg flex flex-col justify-between metric-card ${interactiveClass}" data-metric="${metric.key}"><div><h3 class="text-sm font-medium ${titleColor} font-semibold">${metric.title}</h3><p class="text-3xl font-bold ${valueColor} mt-1">${metric.value}</p></div><p class="text-xs ${subtitleColor} mt-2">${metric.subtitle}</p></div>`;
            };

            if (!selectedYear || !selectedWeek) {
                practitionerSummaryContent.innerHTML = `<p class="col-span-full text-center text-gray-400">Please select a year and week.</p>`;
                patientJourneyContent.innerHTML = '';
                groupClassSection.classList.add('hidden');
                clinicSummaryContent.innerHTML = `<p class="col-span-full text-center text-gray-400">Please select a year and week.</p>`;
                clinicGroupSection.classList.add('hidden');
                return;
            }
            
            const weekStartDate = getStartOfWeek(selectedYear, selectedWeek);
            const weekEndDate = new Date(weekStartDate);
            weekEndDate.setUTCDate(weekStartDate.getUTCDate() + 7);

            // --- Practitioner Dashboard Calculations ---
            if(selectedPractitionerName) {
                const practitionerEventsThisWeek = allEvents.filter(evt => evt['Practitioner'] === selectedPractitionerName && evt.parsedStartTime >= weekStartDate && evt.parsedStartTime < weekEndDate);
                const practitionerAppointmentsThisWeek = practitionerEventsThisWeek.filter(a => parseInt(a['Maximum Number of Patients'], 10) > 0);
                const practitionerInvoicesThisWeek = invoicesData.filter(inv => {
                    const invDate = robustDateParser(inv['Issue Date']); 
                    return invDate && inv.Practitioner?.trim() === selectedPractitionerName.trim() && invDate >= weekStartDate && invDate < weekEndDate;
                });
                
                const totalBookedAppointments = practitionerAppointmentsThisWeek.length;
                const practitionerFixedHours = getPractitionerHoursForDate(selectedPractitionerName, weekStartDate);
                const practitionerFixedMinutes = practitionerFixedHours * 60;
                const attendedAppointmentsTime = practitionerAppointmentsThisWeek.filter(a => parseInt(a['Number of Patients'], 10) > 0);
                const totalAttendedMinutes = attendedAppointmentsTime.reduce((total, appt) => total + (appt.parsedEndTime - appt.parsedStartTime) / 60000, 0);
                const utilizationRate = practitionerFixedMinutes > 0 ? (totalAttendedMinutes / practitionerFixedMinutes) * 100 : 0;
                const weeklyBilledRevenue = practitionerInvoicesThisWeek.reduce((sum, inv) => sum + parseFloat(inv['Invoice Amount'] || 0), 0);
                const cancelledAppointments = practitionerAppointmentsThisWeek.filter(a => a['Cancellation Time'] && a['Cancellation Time'].trim() !== '' && a['Cancellation Time'].toLowerCase() !== 'n/a').length;
                const didNotAttendCount = practitionerAppointmentsThisWeek.filter(a => a['Did Not Arrive']?.trim().toLowerCase() === 'true').length;
                const totalCompletedAppointments = totalBookedAppointments - cancelledAppointments - didNotAttendCount;
                const didNotAttendRate = totalBookedAppointments > 0 ? (didNotAttendCount / totalBookedAppointments) * 100 : 0;
                const cancellationRate = totalBookedAppointments > 0 ? (cancelledAppointments / totalBookedAppointments) * 100 : 0;
                const finalNotesCount = practitionerAppointmentsThisWeek.filter(a => a['Treatment Notes Status'] === 'Final').length;
                const treatmentNoteCompletionRate = totalBookedAppointments > 0 ? (finalNotesCount / totalBookedAppointments) * 100 : 0;
                const uniquePatientsThisWeek = [...new Set(practitionerAppointmentsThisWeek.map(a => a['PatientID(s)']).filter(id => id))];
                const newPatientIdsThisWeek = uniquePatientsThisWeek.filter(patientId => { const firstApptDate = globalPatientFirstAppointment[patientId]; return firstApptDate && firstApptDate >= weekStartDate && firstApptDate < weekEndDate; });
                const newPatientCount = newPatientIdsThisWeek.length;
                const newPatientPercent = uniquePatientsThisWeek.length > 0 ? (newPatientCount / uniquePatientsThisWeek.length) * 100 : 0;
                const pvaCliniko = newPatientCount > 0 ? totalCompletedAppointments / newPatientCount : 0;
                const newPatientsRebooked = newPatientIdsThisWeek.filter(patientId => allEvents.some(appt => appt['PatientID(s)'] === patientId && appt.parsedStartTime >= weekEndDate)).length;
                const iarRate = newPatientCount > 0 ? (newPatientsRebooked / newPatientCount) * 100 : 0;
                const cohortEndDate = new Date(weekStartDate); cohortEndDate.setUTCMonth(cohortEndDate.getUTCMonth() - 3);
                const cohortStartDate = new Date(cohortEndDate); cohortStartDate.setUTCMonth(cohortStartDate.getUTCMonth() - 3);
                const maturedNewPatientCohort = Object.keys(globalPatientFirstAppointment).filter(patientId => {
                    const firstAppt = globalPatientFirstAppointment[patientId];
                    const firstApptPractitioner = allEvents.find(e => e['PatientID(s)'] === patientId && e.parsedStartTime.getTime() === firstAppt.getTime());
                    return firstApptPractitioner && firstApptPractitioner['Practitioner'] === selectedPractitionerName && firstAppt >= cohortStartDate && firstAppt < cohortEndDate;
                });
                let maturedTotalAppointments = 0;
                maturedNewPatientCohort.forEach(patientId => {
                    const firstApptDate = globalPatientFirstAppointment[patientId];
                    const threeMonthsAfterFirstAppt = new Date(firstApptDate); threeMonthsAfterFirstAppt.setUTCMonth(threeMonthsAfterFirstAppt.getUTCMonth() + 3);
                    maturedTotalAppointments += allEvents.filter(appt => appt['PatientID(s)'] === patientId && appt.parsedStartTime >= firstApptDate && appt.parsedStartTime < threeMonthsAfterFirstAppt).length;
                });
                const pvaMatured3Mo = maturedNewPatientCohort.length > 0 ? maturedTotalAppointments / maturedNewPatientCohort.length : 0;
                const allPatientsRebooked = uniquePatientsThisWeek.filter(patientId => allEvents.some(appt => appt['PatientID(s)'] === patientId && appt.parsedStartTime >= weekEndDate)).length;
                const rebookingRate = uniquePatientsThisWeek.length > 0 ? (allPatientsRebooked / uniquePatientsThisWeek.length) * 100 : 0;
                const avgRevenuePerAppointment = totalCompletedAppointments > 0 ? weeklyBilledRevenue / totalCompletedAppointments : 0;
                
                practitionerSummaryContent.innerHTML = ''; patientJourneyContent.innerHTML = '';
                
                const summaryMetrics = [ { key: 'totalBookedAppointments', title: 'Total Booked Appointments', value: totalBookedAppointments, subtitle: 'All available slots' }, { key: 'totalCompletedAppointments', title: 'Total Completed Appointments', value: totalCompletedAppointments, subtitle: `${totalCompletedAppointments} of ${totalBookedAppointments} booked` }, { key: 'utilizationRate', title: 'Utilization %', value: `${utilizationRate.toFixed(1)}%`, subtitle: `${(totalAttendedMinutes / 60).toFixed(1)} of ${practitionerFixedHours.toFixed(1)} hours` }, { key: 'weeklyBilledRevenue', title: 'Weekly Billed Revenue', value: formatCurrency(weeklyBilledRevenue), subtitle: 'Total value of invoices' }, { key: 'cancellationRate', title: 'Cancellation Rate', value: `${cancellationRate.toFixed(1)}%`, subtitle: `${cancelledAppointments} of ${totalBookedAppointments} appointments` }, { key: 'didNotAttendRate', title: 'Did Not Attend %', value: `${didNotAttendRate.toFixed(1)}%`, subtitle: `${didNotAttendCount} of ${totalBookedAppointments} appointments` }, { key: 'newPatientPercent', title: '% of New Patients', value: `${newPatientPercent.toFixed(1)}%`, subtitle: `Of ${uniquePatientsThisWeek.length} unique patients` }, { key: 'rebookingRate', title: 'Rebooking %', value: `${rebookingRate.toFixed(1)}%`, subtitle: 'Patients with future appts' }, { key: 'avgRevenuePerAppointment', title: 'Avg. Revenue / Appt', value: formatCurrency(avgRevenuePerAppointment), subtitle: 'Based on completed appts' }, { key: 'treatmentNoteCompletionRate', title: 'Note Completion %', value: `${treatmentNoteCompletionRate.toFixed(1)}%`, subtitle: `${finalNotesCount} of ${totalBookedAppointments} notes final`}, ];
                const journeyMetrics = [ { key: 'newPatients', title: 'New Patients', value: newPatientCount, subtitle: 'First visit this week' }, { key: 'iarRate', title: 'IAR %', value: `${iarRate.toFixed(1)}%`, subtitle: 'New patients with future appt' }, { key: 'pvaCliniko', title: 'PVA (Cliniko)', value: pvaCliniko.toFixed(1), subtitle: 'Appts / New Patients' }, { key: 'pvaMatured3Mo', title: 'PVA (Matured 3-Mo)', value: pvaMatured3Mo.toFixed(1), subtitle: 'Avg visits for past cohort' }, ];
                
                summaryMetrics.forEach(metric => practitionerSummaryContent.innerHTML += createCardHTML(metric, 'summary', true));
                journeyMetrics.forEach(metric => patientJourneyContent.innerHTML += createCardHTML(metric, 'journey', true));
                
                const groupClassesThisWeek = practitionerAppointmentsThisWeek.filter(a => parseInt(a['Maximum Number of Patients'], 10) > 1);
                if (groupClassesThisWeek.length > 0) {
                    const totalClasses = groupClassesThisWeek.length; const totalAttendance = groupClassesThisWeek.reduce((sum, cls) => sum + parseInt(cls['Number of Patients'] || 0), 0); const totalCancellations = groupClassesThisWeek.reduce((sum, cls) => sum + parseInt(cls['Number of Cancellations'] || 0), 0); const totalPotentialAttendance = totalAttendance + totalCancellations; const classCancellationRate = totalPotentialAttendance > 0 ? (totalCancellations / totalPotentialAttendance) * 100 : 0; const groupRevenue = practitionerInvoicesThisWeek.filter(inv => parseFloat(inv['Invoice Amount']) === 27.50).reduce((sum, inv) => sum + parseFloat(inv['Invoice Amount'] || 0), 0); const groupRevenuePercent = weeklyBilledRevenue > 0 ? (groupRevenue / weeklyBilledRevenue) * 100 : 0;
                    const groupMetrics = [ { key: 'totalClasses', title: 'Total Classes Held', value: totalClasses, subtitle: 'This week' }, { key: 'totalGroupAttendance', title: 'Total Class Attendance', value: totalAttendance, subtitle: 'Number of participants' }, { key: 'totalGroupCancellations', title: 'Class Cancellations', value: totalCancellations, subtitle: 'Recorded cancellations' }, { key: 'classCancellationRate', title: 'Class Cancellation %', value: `${classCancellationRate.toFixed(1)}%`, subtitle: `${totalCancellations} of ${totalPotentialAttendance} bookings` }, { key: 'totalGroupRevenue', title: 'Total Group Revenue', value: formatCurrency(groupRevenue), subtitle: 'From all classes' }, { key: 'groupRevenuePercent', title: '% of Prac Revenue', value: `${groupRevenuePercent.toFixed(1)}%`, subtitle: 'Group contribution to total' }, ];
                    groupClassContent.innerHTML = ''; groupMetrics.forEach(metric => groupClassContent.innerHTML += createCardHTML(metric, 'group', true)); groupClassSection.classList.remove('hidden');
                } else { groupClassSection.classList.add('hidden'); }
            }

            // --- Clinic Dashboard Calculations ---
            const clinicEventsThisWeek = allEvents.filter(evt => evt.parsedStartTime >= weekStartDate && evt.parsedStartTime < weekEndDate);
            const clinicAppointmentsThisWeek = clinicEventsThisWeek.filter(a => parseInt(a['Maximum Number of Patients'], 10) > 0);
            
            const clinicTotalBooked = clinicAppointmentsThisWeek.length;
            const clinicCancelled = clinicAppointmentsThisWeek.filter(a => a['Cancellation Time'] && a['Cancellation Time'].trim() !== '' && a['Cancellation Time'].toLowerCase() !== 'n/a').length;
            const clinicDidNotAttend = clinicAppointmentsThisWeek.filter(a => a['Did Not Arrive']?.trim().toLowerCase() === 'true').length;
            const clinicTotalCompleted = clinicTotalBooked - clinicCancelled - clinicDidNotAttend;
            const clinicCancellationRate = clinicTotalBooked > 0 ? (clinicCancelled / clinicTotalBooked) * 100 : 0;
            const clinicDidNotAttendRate = clinicTotalBooked > 0 ? (clinicDidNotAttend / clinicTotalBooked) * 100 : 0;

            const clinicAttendedMinutes = clinicAppointmentsThisWeek.filter(a => parseInt(a['Number of Patients'], 10) > 0).reduce((total, appt) => total + (appt.parsedEndTime - appt.parsedStartTime) / 60000, 0);
            
            let totalClinicFixedMinutes = 0;
            const uniquePractitionersThisWeek = [...new Set(clinicAppointmentsThisWeek.map(a => a.Practitioner))];
            uniquePractitionersThisWeek.forEach(pracName => {
                totalClinicFixedMinutes += getPractitionerHoursForDate(pracName, weekStartDate) * 60;
            });
            const clinicUtilizationRate = totalClinicFixedMinutes > 0 ? (clinicAttendedMinutes / totalClinicFixedMinutes) * 100 : 0;

            const clinicUniquePatients = [...new Set(clinicAppointmentsThisWeek.map(a => a['PatientID(s)']).filter(id => id))];
            const clinicNewPatientIds = clinicUniquePatients.filter(id => { const first = globalPatientFirstAppointment[id]; return first && first >= weekStartDate && first < weekEndDate; });
            const clinicNewPatientCount = clinicNewPatientIds.length;
            const clinicNewPatientPercent = clinicTotalCompleted > 0 ? (clinicNewPatientCount / clinicTotalCompleted) * 100 : 0;
            const clinicAllRebooked = clinicUniquePatients.filter(id => allEvents.some(a => a['PatientID(s)'] === id && a.parsedStartTime >= weekEndDate)).length;
            const clinicRebookingRate = clinicUniquePatients.length > 0 ? (clinicAllRebooked / clinicUniquePatients.length) * 100 : 0;
            const clinicIAR = clinicNewPatientIds.filter(id => allEvents.some(a => a['PatientID(s)'] === id && a.parsedStartTime >= weekEndDate)).length;
            const clinicIarRate = clinicNewPatientCount > 0 ? (clinicIAR / clinicNewPatientCount) * 100 : 0;
            const clinicNotesCompleted = clinicAppointmentsThisWeek.filter(a => a['Treatment Notes Status'] === 'Final').length;
            const clinicNotesCompletionRate = clinicTotalBooked > 0 ? (clinicNotesCompleted / clinicTotalBooked) * 100 : 0;
            const clinicPvaCliniko = clinicNewPatientCount > 0 ? clinicTotalCompleted / clinicNewPatientCount : 0;
            
            const cohortEndDate = new Date(weekStartDate); cohortEndDate.setUTCMonth(cohortEndDate.getUTCMonth() - 3);
            const cohortStartDate = new Date(cohortEndDate); cohortStartDate.setUTCMonth(cohortStartDate.getUTCMonth() - 3);
            const clinicCohort = Object.keys(globalPatientFirstAppointment).filter(id => { const first = globalPatientFirstAppointment[id]; return first >= cohortStartDate && first < cohortEndDate; });
            let clinicMaturedTotalAppts = 0;
            clinicCohort.forEach(id => {
                const first = globalPatientFirstAppointment[id]; const threeMonthsAfter = new Date(first); threeMonthsAfter.setUTCMonth(threeMonthsAfter.getUTCMonth() + 3);
                clinicMaturedTotalAppts += allEvents.filter(a => a['PatientID(s)'] === id && a.parsedStartTime >= first && a.parsedStartTime < threeMonthsAfter).length;
            });
            const clinicPvaMatured = clinicCohort.length > 0 ? clinicMaturedTotalAppts / clinicCohort.length : 0;

            const clinicSummaryMetrics = [
                { key: 'totalBookedAppointments', title: 'Total Booked Appointments', value: clinicTotalBooked, subtitle: 'Across all practitioners' },
                { key: 'totalCompletedAppointments', title: 'Total Completed Appointments', value: clinicTotalCompleted, subtitle: `${clinicTotalCompleted} of ${clinicTotalBooked} booked` },
                { key: 'utilizationRate', title: 'Total Utilization', value: `${clinicUtilizationRate.toFixed(1)}%`, subtitle: `Based on fixed hours` },
                { key: 'cancellationRate', title: 'Total Cancellation Rate', value: `${clinicCancellationRate.toFixed(1)}%`, subtitle: `${clinicCancelled} cancellations` },
                { key: 'didNotAttendRate', title: 'Total Did Not Attend Rate', value: `${clinicDidNotAttendRate.toFixed(1)}%`, subtitle: `${clinicDidNotAttend} no-shows` },
                { key: 'newPatients', title: 'Number of New Patients', value: clinicNewPatientCount, subtitle: 'Across the clinic' },
                { key: 'newPatientPercent', title: '% of New Patients', value: `${clinicNewPatientPercent.toFixed(1)}%`, subtitle: `Of ${clinicTotalCompleted} completed bookings` },
                { key: 'rebookingRate', title: 'Total Rebooking %', value: `${clinicRebookingRate.toFixed(1)}%`, subtitle: 'All patients with future appts' },
                { key: 'treatmentNoteCompletionRate', title: 'Total Notes Completion', value: `${clinicNotesCompletionRate.toFixed(1)}%`, subtitle: `${clinicNotesCompleted} of ${clinicTotalBooked} notes final` },
                { key: 'iarRate', title: 'Total IAR %', value: `${clinicIarRate.toFixed(1)}%`, subtitle: 'New patients with future appts' },
                 { key: 'pvaCliniko', title: 'Total PVA (Cliniko)', value: clinicPvaCliniko.toFixed(1), subtitle: 'Appts / New Patients' },
                { key: 'pvaMatured3Mo', title: 'Total PVA (Matured)', value: clinicPvaMatured.toFixed(1), subtitle: 'Avg visits for past cohort' },
            ];
            
            clinicSummaryContent.innerHTML = '';
            clinicSummaryMetrics.forEach(metric => clinicSummaryContent.innerHTML += createCardHTML(metric, 'summary', true));

            const clinicGroupClasses = clinicAppointmentsThisWeek.filter(a => parseInt(a['Maximum Number of Patients'], 10) > 1);
            if (clinicGroupClasses.length > 0) {
                const totalClinicClasses = clinicGroupClasses.length;
                const totalClinicAttendance = clinicGroupClasses.reduce((sum, cls) => sum + parseInt(cls['Number of Patients'] || 0), 0);
                const totalClinicCancellations = clinicGroupClasses.reduce((sum, cls) => sum + parseInt(cls['Number of Cancellations'] || 0), 0);
                const totalClinicPotential = totalClinicAttendance + totalClinicCancellations;
                const clinicClassCancellationRate = totalClinicPotential > 0 ? (totalClinicCancellations / totalClinicPotential) * 100 : 0;
                
                const clinicGroupMetrics = [
                    { key: 'totalClasses', title: 'Total Classes Held', value: totalClinicClasses, subtitle: 'Across the clinic' },
                    { key: 'totalGroupAttendance', title: 'Total Class Attendance', value: totalClinicAttendance, subtitle: 'Total participants' },
                    { key: 'totalGroupCancellations', title: 'Class Cancellations', value: totalClinicCancellations, subtitle: 'Total cancellations' },
                    { key: 'classCancellationRate', title: 'Class Cancellation %', value: `${clinicClassCancellationRate.toFixed(1)}%`, subtitle: `${totalClinicCancellations} of ${totalClinicPotential} bookings` },
                ];

                clinicGroupContent.innerHTML = '';
                clinicGroupMetrics.forEach(metric => clinicGroupContent.innerHTML += createCardHTML(metric, 'group', true));
                clinicGroupSection.classList.remove('hidden');
            } else {
                clinicGroupSection.classList.add('hidden');
            }
            
            // --- New Clinic Charts ---
            const completedAppointmentsThisWeek = clinicAppointmentsThisWeek.filter(a => parseInt(a['Number of Patients'], 10) > 0);
            
            const categoryCounts = completedAppointmentsThisWeek.reduce((acc, curr) => {
                const category = curr['Appointment Category'] || 'Uncategorized';
                acc[category] = (acc[category] || 0) + 1;
                return acc;
            }, {});
            
            const categoryColors = {
                'Physiotherapy': '#0F766E', // brand-dark-teal
                'Exercise Physiology': '#BE185D', // brand-dark-pink
                'Chiropractic': '#1F2937',     // brand-text-dark (Black/Dark Grey)
                'Uncategorized': '#9CA3AF'     // A lighter grey
            };
            const chartCategoryColors = Object.keys(categoryCounts).map(cat => categoryColors[cat] || '#6B7280');

            if(categoryMixChart) categoryMixChart.destroy();
            const categoryCtx = document.getElementById('categoryMixChart').getContext('2d');
            categoryMixChart = new Chart(categoryCtx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(categoryCounts),
                    datasets: [{ data: Object.values(categoryCounts), backgroundColor: chartCategoryColors, hoverOffset: 4 }]
                },
                options: { plugins: { legend: { position: 'bottom', labels: { color: '#374151' } } } }
            });

            const initialVsReturn = completedAppointmentsThisWeek.reduce((acc, curr) => {
                 const type = curr['Appointment Type']?.toLowerCase();
                 if (type && (type.includes('initial') || type.includes('first'))) {
                     acc['Initial Appointments'] += 1;
                 } else {
                     acc['Return Appointments'] += 1;
                 }
                 return acc;
            }, { 'Initial Appointments': 0, 'Return Appointments': 0 });
            
            if(typeMixChart) typeMixChart.destroy();
            const typeCtx = document.getElementById('typeMixChart').getContext('2d');
            typeMixChart = new Chart(typeCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Initial Appointments', 'Return Appointments'],
                    datasets: [{ data: [initialVsReturn['Initial Appointments'], initialVsReturn['Return Appointments']], backgroundColor: ['#BE185D', '#0F766E'], hoverOffset: 4 }]
                },
                options: { plugins: { legend: { position: 'bottom', labels: { color: '#374151' } } } }
            });
        }
        
        // --- YEARLY TREND MODAL (Practitioner) ---
        function calculatePractitionerYearlyMetrics(practitionerName, year) {
            const weeksInYear = 53; const yearlyMetrics = {}; const metricKeys = ['totalBookedAppointments', 'totalCompletedAppointments', 'weeklyBilledRevenue', 'cancellationRate', 'didNotAttendRate', 'newPatients', 'newPatientPercent', 'rebookingRate', 'avgRevenuePerAppointment', 'pvaCliniko', 'iarRate', 'pvaMatured3Mo', 'treatmentNoteCompletionRate', 'utilizationRate', 'totalClasses', 'totalGroupAttendance', 'totalGroupCancellations', 'totalGroupRevenue', 'groupRevenuePercent', 'classCancellationRate'];
            metricKeys.forEach(key => yearlyMetrics[key] = Array(weeksInYear).fill(0));
            const practitionerEventsThisYear = allEvents.filter(e => e['Practitioner'] === practitionerName && e.parsedStartTime.getUTCFullYear() === year);
            const practitionerInvoicesThisYear = invoicesData.filter(inv => { if (!inv['Issue Date'] || !inv.Practitioner) return false; const invDate = robustDateParser(inv['Issue Date']); return invDate && inv.Practitioner.trim() === practitionerName.trim() && invDate.getUTCFullYear() === year; });
            const now = new Date();
            for (let week = 1; week <= weeksInYear; week++) {
                const weekIndex = week - 1; const weekStartDate = getStartOfWeek(year, week); if (weekStartDate > now) continue;
                const weekEndDate = new Date(weekStartDate); weekEndDate.setUTCDate(weekStartDate.getUTCDate() + 7);
                const practitionerFixedHours = getPractitionerHoursForDate(practitionerName, weekStartDate); const practitionerFixedMinutes = practitionerFixedHours * 60;
                const eventsThisWeek = practitionerEventsThisYear.filter(e => e.parsedStartTime >= weekStartDate && e.parsedStartTime < weekEndDate);
                const apptsThisWeek = eventsThisWeek.filter(a => parseInt(a['Maximum Number of Patients'], 10) > 0);
                const invoicesThisWeek = practitionerInvoicesThisYear.filter(i => { const invDate = robustDateParser(i['Issue Date']); return invDate >= weekStartDate && invDate < weekEndDate; });
                const totalBooked = apptsThisWeek.length; if (totalBooked === 0 && practitionerFixedMinutes === 0) continue;
                const attendedMinutes = apptsThisWeek.filter(a => parseInt(a['Number of Patients'], 10) > 0).reduce((total, appt) => total + (appt.parsedEndTime - appt.parsedStartTime) / 60000, 0);
                const billedRevenue = invoicesThisWeek.reduce((sum, inv) => sum + parseFloat(inv['Invoice Amount'] || 0), 0);
                const cancelled = apptsThisWeek.filter(a => a['Cancellation Time'] && a['Cancellation Time'].trim() !== '' && a['Cancellation Time'].toLowerCase() !== 'n/a').length;
                const didNotAttend = apptsThisWeek.filter(a => a['Did Not Arrive']?.trim().toLowerCase() === 'true').length;
                const totalCompleted = totalBooked - cancelled - didNotAttend;
                const finalNotes = apptsThisWeek.filter(a => a['Treatment Notes Status'] === 'Final').length;
                const uniquePatients = [...new Set(apptsThisWeek.map(a => a['PatientID(s)']).filter(id => id))];
                const newPatientIds = uniquePatients.filter(id => { const firstDate = globalPatientFirstAppointment[id]; return firstDate && firstDate >= weekStartDate && firstDate < weekEndDate; });
                const newPatientsCount = newPatientIds.length;
                const newPatientsRebooked = newPatientIds.filter(id => allEvents.some(a => a['PatientID(s)'] === id && a.parsedStartTime >= weekEndDate)).length;
                const allPatientsRebooked = uniquePatients.filter(id => allEvents.some(a => a['PatientID(s)'] === id && a.parsedStartTime >= weekEndDate)).length;
                const cohortEndDate = new Date(weekStartDate); cohortEndDate.setUTCMonth(cohortEndDate.getUTCMonth() - 3); const cohortStartDate = new Date(cohortEndDate); cohortStartDate.setUTCMonth(cohortStartDate.getUTCMonth() - 3);
                const cohort = Object.keys(globalPatientFirstAppointment).filter(id => { const firstAppt = globalPatientFirstAppointment[id]; const firstPrac = allEvents.find(e => e['PatientID(s)'] === id && e.parsedStartTime.getTime() === firstAppt.getTime()); return firstPrac && firstPrac['Practitioner'] === practitionerName && firstAppt >= cohortStartDate && firstAppt < cohortEndDate; });
                let followUps = 0;
                cohort.forEach(id => { const firstApptDate = globalPatientFirstAppointment[id]; const threeMonthsAfter = new Date(firstApptDate); threeMonthsAfter.setUTCMonth(threeMonthsAfter.getUTCMonth() + 3); followUps += allEvents.filter(a => a['PatientID(s)'] === id && a.parsedStartTime >= firstApptDate && a.parsedStartTime < threeMonthsAfter).length; });
                const groupClasses = apptsThisWeek.filter(a => parseInt(a['Maximum Number of Patients'], 10) > 1);
                const groupRevenue = invoicesThisWeek.filter(inv => parseFloat(inv['Invoice Amount']) === 27.50).reduce((sum, inv) => sum + parseFloat(inv['Invoice Amount'] || 0), 0);
                const groupCancellations = groupClasses.reduce((sum, cls) => sum + parseInt(cls['Number of Cancellations'] || 0), 0);
                const groupAttendance = groupClasses.reduce((sum, cls) => sum + parseInt(cls['Number of Patients'] || 0), 0);
                const groupTotalPotential = groupAttendance + groupCancellations;
                yearlyMetrics.totalBookedAppointments[weekIndex] = totalBooked; yearlyMetrics.totalCompletedAppointments[weekIndex] = totalCompleted; yearlyMetrics.utilizationRate[weekIndex] = practitionerFixedMinutes > 0 ? (attendedMinutes / practitionerFixedMinutes) * 100 : 0; yearlyMetrics.weeklyBilledRevenue[weekIndex] = billedRevenue; yearlyMetrics.cancellationRate[weekIndex] = totalBooked > 0 ? (cancelled / totalBooked) * 100 : 0; yearlyMetrics.didNotAttendRate[weekIndex] = totalBooked > 0 ? (didNotAttend / totalBooked) * 100 : 0; yearlyMetrics.treatmentNoteCompletionRate[weekIndex] = totalBooked > 0 ? (finalNotes / totalBooked) * 100 : 0; yearlyMetrics.newPatients[weekIndex] = newPatientsCount; yearlyMetrics.newPatientPercent[weekIndex] = uniquePatients.length > 0 ? (newPatientsCount / uniquePatients.length) * 100 : 0; yearlyMetrics.rebookingRate[weekIndex] = uniquePatients.length > 0 ? (allPatientsRebooked / uniquePatients.length) * 100 : 0; yearlyMetrics.avgRevenuePerAppointment[weekIndex] = totalCompleted > 0 ? billedRevenue / totalCompleted : 0; yearlyMetrics.pvaCliniko[weekIndex] = newPatientsCount > 0 ? totalCompleted / newPatientsCount : 0; yearlyMetrics.iarRate[weekIndex] = newPatientsCount > 0 ? (newPatientsRebooked / newPatientsCount) * 100 : 0; yearlyMetrics.pvaMatured3Mo[weekIndex] = cohort.length > 0 ? followUps / cohort.length : 0; yearlyMetrics.totalClasses[weekIndex] = groupClasses.length; yearlyMetrics.totalGroupAttendance[weekIndex] = groupAttendance; yearlyMetrics.totalGroupCancellations[weekIndex] = groupCancellations; yearlyMetrics.totalGroupRevenue[weekIndex] = groupRevenue; yearlyMetrics.groupRevenuePercent[weekIndex] = billedRevenue > 0 ? (groupRevenue / billedRevenue) * 100 : 0; yearlyMetrics.classCancellationRate[weekIndex] = groupTotalPotential > 0 ? (groupCancellations / groupTotalPotential) * 100 : 0;
            }
            return yearlyMetrics;
        }

         // --- YEARLY TREND MODAL (Clinic) ---
        function calculateClinicYearlyMetrics(year) {
            const weeksInYear = 53; const yearlyMetrics = {}; const metricKeys = ['totalBookedAppointments', 'totalCompletedAppointments', 'utilizationRate', 'cancellationRate', 'didNotAttendRate', 'newPatients', 'newPatientPercent', 'rebookingRate', 'treatmentNoteCompletionRate', 'iarRate', 'pvaCliniko', 'pvaMatured3Mo', 'totalClasses', 'totalGroupAttendance', 'totalGroupCancellations', 'classCancellationRate'];
            metricKeys.forEach(key => yearlyMetrics[key] = Array(weeksInYear).fill(0));
            const now = new Date();
            for (let week = 1; week <= weeksInYear; week++) {
                const weekIndex = week - 1; const weekStartDate = getStartOfWeek(year, week); if (weekStartDate > now) continue;
                const weekEndDate = new Date(weekStartDate); weekEndDate.setUTCDate(weekStartDate.getUTCDate() + 7);
                const apptsThisWeek = allEvents.filter(e => e.parsedStartTime >= weekStartDate && e.parsedStartTime < weekEndDate && parseInt(e['Maximum Number of Patients'], 10) > 0);
                const totalBooked = apptsThisWeek.length; if (totalBooked === 0) continue;
                const cancelled = apptsThisWeek.filter(a => a['Cancellation Time'] && a['Cancellation Time'].trim() !== '' && a['Cancellation Time'].toLowerCase() !== 'n/a').length;
                const didNotAttend = apptsThisWeek.filter(a => a['Did Not Arrive']?.trim().toLowerCase() === 'true').length;
                const totalCompleted = totalBooked - cancelled - didNotAttend;
                const attendedMinutes = apptsThisWeek.filter(a => parseInt(a['Number of Patients'], 10) > 0).reduce((total, appt) => total + (appt.parsedEndTime - appt.parsedStartTime) / 60000, 0);
                let totalFixedMinutes = 0;
                const uniquePracs = [...new Set(apptsThisWeek.map(a => a.Practitioner))];
                uniquePracs.forEach(name => { totalFixedMinutes += getPractitionerHoursForDate(name, weekStartDate) * 60; });
                const uniquePatients = [...new Set(apptsThisWeek.map(a => a['PatientID(s)']).filter(id => id))];
                const newPatientIds = uniquePatients.filter(id => { const first = globalPatientFirstAppointment[id]; return first && first >= weekStartDate && first < weekEndDate; });
                const newPatientsCount = newPatientIds.length;
                const rebooked = uniquePatients.filter(id => allEvents.some(a => a['PatientID(s)'] === id && a.parsedStartTime >= weekEndDate)).length;
                const iar = newPatientIds.filter(id => allEvents.some(a => a['PatientID(s)'] === id && a.parsedStartTime >= weekEndDate)).length;
                const notesCompleted = apptsThisWeek.filter(a => a['Treatment Notes Status'] === 'Final').length;
                const cohortEndDate = new Date(weekStartDate); cohortEndDate.setUTCMonth(cohortEndDate.getUTCMonth() - 3); const cohortStartDate = new Date(cohortEndDate); cohortStartDate.setUTCMonth(cohortStartDate.getUTCMonth() - 3);
                const clinicCohort = Object.keys(globalPatientFirstAppointment).filter(id => { const first = globalPatientFirstAppointment[id]; return first >= cohortStartDate && first < cohortEndDate; });
                let maturedAppts = 0;
                clinicCohort.forEach(id => { const first = globalPatientFirstAppointment[id]; const threeMonthsAfter = new Date(first); threeMonthsAfter.setUTCMonth(threeMonthsAfter.getUTCMonth() + 3); maturedAppts += allEvents.filter(a => a['PatientID(s)'] === id && a.parsedStartTime >= first && a.parsedStartTime < threeMonthsAfter).length; });
                const groupClasses = apptsThisWeek.filter(a => parseInt(a['Maximum Number of Patients'], 10) > 1);
                const groupCancellations = groupClasses.reduce((sum, cls) => sum + parseInt(cls['Number of Cancellations'] || 0), 0);
                const groupAttendance = groupClasses.reduce((sum, cls) => sum + parseInt(cls['Number of Patients'] || 0), 0);
                const groupTotalPotential = groupAttendance + groupCancellations;

                yearlyMetrics.totalBookedAppointments[weekIndex] = totalBooked; yearlyMetrics.totalCompletedAppointments[weekIndex] = totalCompleted; yearlyMetrics.utilizationRate[weekIndex] = totalFixedMinutes > 0 ? (attendedMinutes / totalFixedMinutes) * 100 : 0; yearlyMetrics.cancellationRate[weekIndex] = totalBooked > 0 ? (cancelled / totalBooked) * 100 : 0; yearlyMetrics.didNotAttendRate[weekIndex] = totalBooked > 0 ? (didNotAttend / totalBooked) * 100 : 0; yearlyMetrics.newPatients[weekIndex] = newPatientsCount; yearlyMetrics.newPatientPercent[weekIndex] = totalCompleted > 0 ? (newPatientsCount / totalCompleted) * 100 : 0; yearlyMetrics.rebookingRate[weekIndex] = uniquePatients.length > 0 ? (rebooked / uniquePatients.length) * 100 : 0; yearlyMetrics.treatmentNoteCompletionRate[weekIndex] = totalBooked > 0 ? (notesCompleted / totalBooked) * 100 : 0; yearlyMetrics.iarRate[weekIndex] = newPatientsCount > 0 ? (iar / newPatientsCount) * 100 : 0; yearlyMetrics.pvaCliniko[weekIndex] = newPatientsCount > 0 ? totalCompleted / newPatientsCount : 0; yearlyMetrics.pvaMatured3Mo[weekIndex] = cohort.length > 0 ? maturedAppts / cohort.length : 0;
                yearlyMetrics.totalClasses[weekIndex] = groupClasses.length; yearlyMetrics.totalGroupAttendance[weekIndex] = groupAttendance; yearlyMetrics.totalGroupCancellations[weekIndex] = groupCancellations; yearlyMetrics.classCancellationRate[weekIndex] = groupTotalPotential > 0 ? (groupCancellations / groupTotalPotential) * 100 : 0;
            }
            return yearlyMetrics;
        }

        function showPractitionerYearlyTrendChart(metricType, metricTitle) {
            const selectedPractitionerName = document.getElementById('practitioner-select').value;
            const selectedYear = parseInt(document.getElementById('year-select').value);
            const yearlyData = calculatePractitionerYearlyMetrics(selectedPractitionerName, selectedYear);
            renderChartInModal(metricType, metricTitle, selectedYear, yearlyData, '#BE185D', 'rgba(190, 24, 93, 0.2)');
        }

        function showClinicYearlyTrendChart(metricType, metricTitle) {
            const selectedYear = parseInt(document.getElementById('year-select').value);
            const yearlyData = calculateClinicYearlyMetrics(selectedYear);
            renderChartInModal(metricType, metricTitle, selectedYear, yearlyData, '#0F766E', 'rgba(15, 118, 110, 0.2)');
        }
        
        function renderChartInModal(metricType, metricTitle, year, yearlyData, color, bgColor) {
            const modal = document.getElementById('chart-modal');
            const modalTitle = document.getElementById('modal-title');
            const q1AvgEl = document.getElementById('modal-q1-avg');
            const q2AvgEl = document.getElementById('modal-q2-avg');
            const q3AvgEl = document.getElementById('modal-q3-avg');
            const q4AvgEl = document.getElementById('modal-q4-avg');
            const annualAvgEl = document.getElementById('modal-annual-avg');
            
            modalTitle.textContent = `${metricTitle} Trend for ${year}`;
            
            const chartData = yearlyData[metricType];
            if (!chartData) { console.error(`No chart data found for metric: ${metricType}`); return; }
            
            const weeksInYear = 53; const labels = Array.from({ length: weeksInYear }, (_, i) => `W${i + 1}`);
            const isCurrency = metricType.toLowerCase().includes('revenue');
            const isPercent = metricType.toLowerCase().includes('rate') || metricType.toLowerCase().includes('percent') || metricType.toLowerCase().includes('completion');

            // Calculate Averages
            const validValues = chartData.filter(v => v > 0);
            const annualAvg = validValues.length > 0 ? validValues.reduce((a, b) => a + b, 0) / validValues.length : 0;
            
            const quarterlyAverages = [];
            for (let i = 0; i < 4; i++) {
                const quarterStartWeek = i * 13;
                const quarterEndWeek = quarterStartWeek + 13;
                const quarterValues = chartData.slice(quarterStartWeek, quarterEndWeek).filter(v => v > 0);
                const avg = quarterValues.length > 0 ? quarterValues.reduce((a, b) => a + b, 0) / quarterValues.length : 0;
                quarterlyAverages.push(avg);
            }

            const formatValue = (val) => {
                 if (isCurrency) return formatCurrency(val);
                 if (isPercent) return `${val.toFixed(1)}%`;
                 return val.toFixed(1);
            }
            
            q1AvgEl.textContent = formatValue(quarterlyAverages[0]);
            q2AvgEl.textContent = formatValue(quarterlyAverages[1]);
            q3AvgEl.textContent = formatValue(quarterlyAverages[2]);
            q4AvgEl.textContent = formatValue(quarterlyAverages[3]);
            annualAvgEl.textContent = formatValue(annualAvg);


            const datasets = [{ label: metricTitle, data: chartData, borderColor: color, backgroundColor: bgColor, fill: true, tension: 0.4 }];
            
            // Contextual benchmark check
            const isClinicChart = color === '#0F766E';
            let showBenchmark = true;
            if (!isClinicChart && (metricType === 'totalBookedAppointments' || metricType === 'totalCompletedAppointments')) {
                showBenchmark = false;
            }
            
            const benchmarkValue = METRIC_BENCHMARKS[metricType];
            if(benchmarkValue !== undefined && showBenchmark) {
                datasets.push({ label: 'Benchmark', data: Array(weeksInYear).fill(benchmarkValue), borderColor: '#6B7280', borderWidth: 2, borderDash: [5, 5], pointRadius: 0, fill: false, tension: 0 });
            }

            if (modalChart) modalChart.destroy();
            const modalCtx = document.getElementById('modal-chart').getContext('2d');
            modalChart = new Chart(modalCtx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    scales: {
                        y: { beginAtZero: true, grid: { color: '#E5E7EB' }, ticks: { color: '#374151', callback: function(value) { if (isCurrency) return formatCurrency(value); if (isPercent) return `${value.toFixed(1)}%`; return value; } } },
                        x: { grid: { display: false }, ticks: { color: '#374151' } }
                    },
                    plugins: { legend: { display: true, position: 'top', labels: { color: '#374151' } } }
                }
            });
            modal.classList.remove('hidden');
        }
    </script>
</body>
</html>

